% Generated by roxygen2 (4.0.1): do not edit by hand
\name{fullCoverage}
\alias{fullCoverage}
\title{Load the unfiltered coverage information from a group of BAM files and a
list of chromosomes}
\usage{
fullCoverage(dirs, chrs, bai = NULL, chrlens = NULL, outputs = NULL,
  mc.cores = getOption("mc.cores", 1L),
  mc.outfile = Sys.getenv("SGE_STDERR_PATH"), cutoff = NULL,
  inputType = "bam", isMinusStrand = NA, filter = "one",
  returnMean = FALSE, returnCoverage = TRUE, totalMapped = NULL,
  targetSize = 8e+07, chrsStyle = "UCSC", verbose = TRUE)
}
\arguments{
\item{dirs}{A character vector with the full path to the sample BAM files
(or bigWig files).
The names are used for the column names of the DataFrame. Check
\link{makeBamList} for constructing \code{dirs}. \code{dirs} can also be a
\code{BamFileList} object created with \link[Rsamtools]{BamFileList} or a
\code{BigWigFileList} object created with \link[rtracklayer]{BigWigFileList}.}

\item{chrs}{The chromosome of the files to read. The format has to match the
one used in the input files.}

\item{bai}{The full path to the BAM index files. If \code{NULL} it is
assumed that the BAM index files are in the same location as the BAM files
and that they have the .bai extension. Ignored if \code{dirs} is a
\code{BamFileList} object.}

\item{chrlens}{The chromosome lengths in base pairs. If it's \code{NULL},
the chromosome length is extracted from the BAM files. Otherwise, it should
have the same length as \code{chrs}.}

\item{outputs}{This argument is passed to the \code{output} argument of
\link{loadCoverage}. If \code{NULL} or \code{'auto'} it is then recycled.}

\item{mc.cores}{This argument is passed to \link[BiocParallel]{SnowParam}
to define the number of \code{workers}. You should use at most one core per
chromosome.}

\item{mc.outfile}{This argument is passed to \link[BiocParallel]{SnowParam}
to specify the \code{outfile} for any output from the workers.}

\item{cutoff}{This argument is passed to \link{filterData}. If set to
\code{NULL}, then the data is loaded and only the \code{$coverage} is
returned.}

\item{inputType}{Has to be either \code{bam} or \code{bigWig}. It specifies
the format of the raw data files.}

\item{isMinusStrand}{Use \code{TRUE} for negative strand alignments only,
\code{FALSE} for positive strands and \code{NA} for both. This argument is
passed to \link[Rsamtools]{scanBamFlag} when \code{inputType='bam'}.}

\item{filter}{This argument is passed to \link{filterData}. It is only used
when \code{cutoff} is non-NULL.}

\item{returnMean}{This argument is passed to \link{filterData}. It is only
used when \code{cutoff} is non-NULL.}

\item{returnCoverage}{This argument is passed to \link{filterData}. It is
only used when \code{cutoff} is non-NULL.}

\item{totalMapped}{The total number of reads mapped for each sample.
Providing this data adjusts the coverage to reads in \code{targetSize}
library prior to filtering. By default, to reads per 80 million reads.}

\item{targetSize}{The target library size to adjust the coverage to. Used
only when \code{totalMapped} is specified.}

\item{chrsStyle}{The naming style of the chromosomes. By default, UCSC. See
\link[GenomeInfoDb]{seqlevelsStyle}.}

\item{verbose}{If \code{TRUE} basic status updates will be printed along the
way.}
}
\value{
A list with one element per chromosome.
\describe{ Each element is a DataFrame with the coverage information
produced by \link{loadCoverage}.
}
}
\description{
For a group of samples this function reads the coverage information for
several chromosomes directly from the BAM files. Per chromosome, it merges
the unfiltered coverage by sample into a DataFrame. The end result is a list
with one such DataFrame objects per chromosome.
}
\examples{
datadir <- system.file('extdata', 'genomeData', package='derfinder')
dirs <- makeBamList(datadir=datadir, samplepatt='*accepted_hits.bam$',
    bamterm=NULL)
## Shorten the column names
names(dirs) <- gsub('_accepted_hits.bam', '', names(dirs))

## Read and filter the data, only for 1 file
fullCov <- fullCoverage(dirs=dirs[1], chrs=c('21', '22'))
fullCov

\dontrun{
## You can then use filterData() to filter the data if you want to.
## Use bplapply() if you want to do so with multiple cores as shown below.
library('BiocParallel')
p <- SnowParam(2L, outfile = Sys.getenv('SGE_STDERR_PATH'))
bplapply(fullCov, function(x) {
    library('derfinder'); filterData(x, cutoff=0) }, BPPARAM = p)
}
}
\author{
Leonardo Collado-Torres
}
\seealso{
\link{loadCoverage}, \link{filterData}
}

