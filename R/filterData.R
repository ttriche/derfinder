#' Filter the positions of interest
#'
#' For a group of samples this function reads the coverage information for a 
#' specific chromosome directly from the BAM files. It then merges them into a 
#' DataFrame and removes the bases that do not pass the cutoff. This is a 
#' helper function for \link{loadCoverage} and \link{preprocessCoverage}.
#' 
#' @param data Either a list of Rle objects or a DataFrame with the coverage 
#' information.
#' @param cutoff Per base pair, at least one sample has to have coverage 
#' strictly greater than \code{cutoff} to be included in the result.
#' @param index A logical Rle with the positions of the chromosome that passed 
#' the cutoff. If \code{NULL} it is assumed that this is the first time using 
#' \link{filterData} and thus no previous index exists.
#' @param colnames Specifies the column names to be used for the results 
#' DataFrame. If \code{NULL}, names from \code{data} are used.
#' @param filter Has to be either \code{"one"} (default) or \code{"mean"}. In 
#' the first case, at least one sample has to have coverage above \code{cutoff}.
#' In the second case, the mean coverage has to be greater than \code{cutoff}.
#' @param returnMean If \code{TRUE} the mean coverage is included in the result.
#' @param returnCoverage If \code{TRUE}, the coverage DataFrame is returned.
#' @param totalMapped The total number of reads mapped for each sample. 
#' Providing this data adjusts the coverage to reads in \code{targetSize} 
#' library prior to filtering. By default, to reads per 80 million reads.
#' @param targetSize The target library size to adjust the coverage to. Used
#' only when \code{totalMapped} is specified.
#' @param verbose If \code{TRUE} it will report how many rows are remaining out 
#' of the original ones.
#'
#' @return A list with up to three components.
#' \code{returnMean = TRUE}. 
#' \describe{
#' \item{coverage }{ is a DataFrame object where each column represents a 
#' sample. The number of rows depends on the number of base pairs that passed 
#' the cutoff and the information stored is the coverage at that given base. 
#' Included only when \code{returnCoverage = TRUE}.}
#' \item{position }{  is a logical Rle with the positions of the chromosome 
#' that passed the cutoff.}
#' \item{meanCoverage }{ is a numeric Rle with the mean coverage at each base. 
#' Included only when \code{returnMean = TRUE}.}
#' }
#'
#' @details If \code{cutoff} is \code{NULL} then the data is grouped into 
#' DataFrame without applying any cutoffs. This can be useful if you want to 
#' use \link{loadCoverage} to build the coverage DataFrame without applying any 
#' cutoffs for other downstream purposes like plotting the coverage values of a 
#' given region. You can always specify the \code{colsubset} argument in 
#' \link{preprocessCoverage} to filter the data before calculating the F 
#' statistics.
#'
#' @author Leonardo Collado-Torres
#' @export
#' @importFrom IRanges DataFrame Rle
#' @importMethodsFrom IRanges '[' '[<-' '[[' colnames 'colnames<-' lapply Reduce
#' @seealso \link{loadCoverage}, \link{preprocessCoverage}
#' @examples
#' library('IRanges')
#' x <- Rle(round(runif(1e4, max=10)))
#' y <- Rle(round(runif(1e4, max=10)))
#' z <- Rle(round(runif(1e4, max=10)))
#' DF <- DataFrame(x, y, z)
#' filt1 <- filterData(DF, 5)
#' filt1
#' filt2 <- filterData(filt1$coverage[, 1:2], 5, index=filt1$position)
#' filt2
#' ## The number of TRUE values in 'position' is the same as the number of rows 
#' ## as in 'coverage'.
#' identical(sum(filt2$pos), nrow(filt2$cov))

filterData <- function(data, cutoff = NULL, index = NULL, colnames = NULL,
    filter = "one", returnMean = FALSE, returnCoverage = TRUE,
    totalMapped = NULL, targetSize = 80e6, verbose = TRUE) {
        
    ## Check filter
    stopifnot(filter %in% c("one", "mean"))
    
    ## Initialize meanCov
    meanCov <- NULL
    
    ## library size adjustments
    if(!is.null(totalMapped) & targetSize != 0) {
        mappedPerXM <- totalMapped / targetSize
        
        ## Normalize to a given library size
        if (verbose) 
            message(paste(Sys.time(), "filterData: normalizing coverage"))
        data <- mapply(function(x, d) x / d, data, mappedPerXM)
        if (verbose) 
            message(paste(Sys.time(), "filterData: done normalizing coverage"))
    }
    
    ## If there is no cutoff to apply, just build the DataFrame
    if (is.null(cutoff)) {
        newindex <- NULL
        finalidx <- index
    } else {
        ## Construct the filtering index
        if(filter == "one") {
            for (i in seq_len(length(data))) {
                if (i == 1) {
                    newindex <- data[[i]] > cutoff
                } else {
                    newindex <- newindex | data[[i]] > cutoff
                }
            }
        } else if (filter == "mean") {
            meanCov <- Reduce("+", data) / length(data)
            newindex <- meanCov > cutoff
        }
        
        ## Build the final index
        if (!is.null(index)) {
            finalidx <- index
            finalidx[index] <- newindex
        } else {
            finalidx <- newindex
        }
    }
    
    ## Keep only bases that pass the cutoff
    if(returnMean) {
        if(is.null(meanCov)) {
            ## Calculate the mean if needed
            meanCov <- Reduce("+", data) / length(data)
        }
        if(!is.null(newindex)) {
            meanCovFiltered <- meanCov[newindex]
        } else {
            meanCovFiltered <- meanCov
        }
    }
    
    if(returnCoverage) {
        if (is(data, "DataFrame")) {
            if (!is.null(newindex)) {
                DF <- data[newindex, ]
            } else {
                DF <- data
            }
        } else {
            ## Subset the data and group into DataFrame
            if (!is.null(newindex)) {
                DF <- DataFrame(lapply(data, function(x) {
                    x[newindex]
                }))
            } else {
                DF <- DataFrame(data)
            }
        }
    }
        
    ## Info for the user
    if (verbose) {
        if(returnCoverage) {
            message(paste(Sys.time(), "filterData: originally there were", 
                length(data[[1]]), "rows, now there are", nrow(DF), 
                "rows. Meaning that", 100 - round(nrow(DF)/length(data[[1]]) * 
                    100, 2), "percent was filtered."))
        } else if (returnMean) {
            message(paste(Sys.time(), "filterData: originally there were", 
                length(data[[1]]), "rows, now there are", 
                length(meanCovFiltered), "rows. Meaning that", 100 - 
                round(length(meanCovFiltered)/length(data[[1]]) * 
                    100, 2), "percent was filtered."))
        }
    }
    
    ## Assign column names
    if(returnCoverage) {
        if (!is.null(colnames)) {
            colnames(DF) <- colnames
        }
    }
    
    ## Make the final resulting object.
    if(returnMean & returnCoverage) {
        res <- list(coverage = DF, position = finalidx, 
            meanCoverage = meanCovFiltered)   
    } else if (!returnMean & returnCoverage){
        res <- list(coverage = DF, position = finalidx)
    } else if (returnMean & !returnCoverage) {
        res <- list(position = finalidx, meanCoverage = meanCovFiltered)
    } else {
        res <- list(position = finalidx)
    }
    
    return(res)
} 
